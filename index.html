<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BISH BASH BOSH â€“ Whack-a-Mole</title>
 <style>

/* =====================================================
   1) BASE / GLOBAL STYLES
   ===================================================== */

:root {
  --bg: #05070c;
  --bg-panel: #0b111b;
  --bg-panel-alt: #101827;
  --accent: #43ff99;
  --accent-soft: rgba(67, 255, 153, 0.18);
  --accent-strong: #63ffb0;
  --text: #f7f9ff;
  --muted: #8c9bb8;
  --danger: #ff5577;
  --border-soft: #1b2538;
  --shadow-soft: 0 18px 40px rgba(0,0,0,0.8);
  --radius-lg: 18px;
  --radius-pill: 999px;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
html,
body {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden; /* CRITICAL: browser cannot scroll */
  background: #05070c;
}

body {
  display: block; /* NOT flex */
  color: var(--text);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
}



/* ================= GAME SHELL ================= */

.game-shell {
  position: fixed;
  inset: 0; /* TOP, RIGHT, BOTTOM, LEFT = 0 */
  
  width: 100%;
  height: 100svh;

  background: radial-gradient(circle at top left, #141f33, #05070c);

  display: flex;
  flex-direction: column;
  gap: 12px;

  padding: 12px;

  overflow: hidden; /* SLOT NEVER SCROLLS */
}



/* ================= HUD ================= */

.hud {
  display: grid;
  grid-template-columns: repeat(3, minmax(0,1fr));
  gap: 10px;
}

/* ================= REELS ================= */

.reel-wrapper {
  flex: 1;
  padding: 8px;
  border-radius: 20px;
  background: radial-gradient(circle at top, rgba(32,50,70,0.95), rgba(3,6,18,0.98));
  border: 1px solid rgba(255,255,255,0.06);
  display: flex;
}

.reels {
  flex: 1;
  display: grid;
  grid-template-columns: repeat(5, minmax(0,1fr));
  gap: 6px;
}

.reel {
  background: radial-gradient(circle at center, #111827, #050712);
  border-radius: 16px;
  padding: 6px 4px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.symbol {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 2px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.05);
  position: relative;
}

.symbol-img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  transform: scale(0.9);
}

/* =====================================================
   2) EFFECTS
   ===================================================== */

.symbol-win {
  box-shadow: 0 0 20px rgba(250,204,21,0.75);
}

/* =====================================================
   3) LANDSCAPE COMPACT
   ===================================================== */

@media (orientation: landscape) and (max-height: 520px) {
  .game-shell {
    padding-top: 6px;
    gap: 8px;
  }

  .reel-wrapper {
    padding: 6px;
  }
}

/* =====================================================
   4) iPHONE PORTRAIT â€” FINAL & ONLY MOBILE OVERRIDE
   ===================================================== */

@media (orientation: portrait) and (max-width: 430px) {

  body {
    background: #05070c;
  }


  

  .hud {
    gap: 6px;
    margin-top: 2px;
  }

  .reel-wrapper {
    padding: 6px;
    margin-top: 4px;
    flex: 1;
  }

  .reels {
    gap: 4px;
  }

  .reel {
    padding: 4px 3px;
    border-radius: 14px;
  }

  .symbol {
    padding: 1px;
    border-radius: 10px;
  }

  .symbol-img {
    transform: scale(0.96);
  }

  .symbol[data-symbol="SCAT"] .symbol-img {
    transform: scale(1.02);
  }

  .symbol[data-symbol="10"] .symbol-img,
  .symbol[data-symbol="J"]  .symbol-img,
  .symbol[data-symbol="Q"]  .symbol-img,
  .symbol[data-symbol="K"]  .symbol-img,
  .symbol[data-symbol="A"]  .symbol-img {
    transform: scale(0.9);
  }
}
   /* =====================================================
   STEP 2 â€” SYMBOL FRAME & MOBILE STABILITY FIX
   ===================================================== */

/* Ensure symbol cell is the positioning context */
.symbol {
  position: relative;
  overflow: hidden;
}

/* Inner frame is the visual container */
.symbol-frame {
  position: absolute;
  inset: 4%;
  border-radius: inherit;
  pointer-events: none;
}

/* Image sits cleanly inside frame */
.symbol-img {
  position: relative;
  z-index: 2;
  width: 100%;
  height: 100%;
  object-fit: contain;
}

/* Win glow applies to FRAME, not whole cell */
.symbol-win .symbol-frame {
  box-shadow: 0 0 18px rgba(250, 204, 21, 0.65);
}

/* Remove glow from the outer cell */
.symbol-win {
  box-shadow: none;/* =====================================================
   STEP 3 â€” CABINET DEPTH & REEL POLISH
   ===================================================== */

/* Reel wrapper becomes a cabinet window */
.reel-wrapper {
  position: relative;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.06),
    inset 0 18px 40px rgba(0,0,0,0.75),
    0 30px 60px rgba(0,0,0,0.85);
}

/* Soft inner vignette */
.reel-wrapper::before {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  border-radius: inherit;
  background: radial-gradient(
    ellipse at center,
    rgba(255,255,255,0.04),
    rgba(0,0,0,0.65)
  );
  z-index: 2;
}

/* Reels sit below vignette */
.reels {
  position: relative;
  z-index: 1;
}

/* Individual reel depth */
.reel {
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.05),
    inset 0 -14px 28px rgba(0,0,0,0.65);
}

/* Symbol cell depth */
.symbol {
  background: radial-gradient(
    ellipse at top,
    rgba(255,255,255,0.06),
    rgba(0,0,0,0.55)
  );
}

/* Subtle idle lift */
.symbol-img {
  transition:
    transform 160ms ease,
    filter 160ms ease;
}

/* Win lift + brightness */
.symbol-win .symbol-img {
  transform: scale(1.05);
  filter: brightness(1.15);
}

/* Reel win rail glow */
.reel.win-rail {
  box-shadow:
    0 0 18px rgba(67,255,153,0.35),
    inset 0 0 0 1px rgba(67,255,153,0.25);
}

/* Mobile density tuning */
@media (orientation: portrait) and (max-width: 430px) {

  .reel-wrapper {
    box-shadow:
      inset 0 0 0 1px rgba(255,255,255,0.05),
      inset 0 12px 26px rgba(0,0,0,0.75),
      0 18px 36px rgba(0,0,0,0.8);
  }

  .symbol-win .symbol-img {
    transform: scale(1.03);
  }
}


   /* =====================================================
   PHASE 2 â€” SLOT CABINET VISUAL BALANCE
   Balanced reels + controls (desktop & mobile)
   ===================================================== */

/* --- HEADER COMPRESSION --- */
.game-header {
  padding: 6px 0 4px;
}

.game-title {
  font-size: 18px;
}

.game-subtitle {
  font-size: 12px;
  opacity: 0.85;
}

/* --- HUD TIGHTENING --- */
.hud {
  gap: 6px;
}

.hud-block {
  padding: 6px 8px;
}

.hud-label {
  font-size: 11px;
}

.hud-value {
  font-size: 15px;
}

/* --- REELS DOMINANCE --- */
.reel-wrapper {
  flex: 1 1 auto;
  padding: 10px;
}

.reels {
  height: 100%;
}

.reel {
  gap: 6px;
}

.symbol {
  min-height: 0;
}

/* --- CONTROLS ANCHORED & BALANCED --- */
.controls {
  display: grid;
  grid-template-columns: 1fr 1.3fr 1fr;
  gap: 8px;
  padding-top: 4px;
}

.controls .btn {
  height: 56px;
  font-size: 15px;
}

#spin-btn {
  height: 64px;
  font-size: 17px;
}

/* --- STATUS BAR COMPRESSION --- */
.status-bar {
  padding: 4px 0 2px;
  font-size: 11px;
}

.status-left .tag {
  padding: 2px 6px;
}

/* =====================================================
   MOBILE PORTRAIT â€” FINAL BALANCE TUNING
   ===================================================== */

@media (orientation: portrait) and (max-width: 430px) {

  .game-shell {
    padding: 8px;
  }

  .game-header {
    padding: 4px 0;
  }

  .game-title {
    font-size: 16px;
  }

  .game-subtitle {
    font-size: 11px;
  }

  .reel-wrapper {
    padding: 8px;
  }

  .controls {
    gap: 6px;
  }

  #spin-btn {
    height: 66px;
    font-size: 18px;
  }

  .status-bar {
    font-size: 10px;
  }
}

/* =====================================================
   DESKTOP CABINET CENTERING (PHASE 1)
   ===================================================== */

@media (min-width: 768px) {
  .game-shell {
    align-items: center;
  }

  .game-shell > * {
    width: 100%;
    max-width: 1400px;
  }
}

</style>






</head>
<body>
<div class="game-shell">
  <div id="fs-banner" class="fs-banner">
    <span id="fs-banner-text">FREE SPINS LEFT</span>
  </div>

  <header class="game-header">
    <div class="game-title-block">
      <div class="game-title">BISH BASH BOSH</div>
      <div class="game-subtitle">Whack-a-Mole Â· 5Ã—3 Â· 10 lines Â· Free Spins Feature</div>
    </div>
    <div class="header-right">
      <div class="game-pill">
        <span class="game-pill-dot"></span>
        <span>Base Game + Free Spins â€¢ <strong>Local RNG</strong></span>
      </div>
      <button id="info-btn" class="info-toggle" aria-label="Game information">
        â“˜
      </button>
      <button id="sound-btn" class="sound-toggle" aria-label="Toggle sound">
        <span id="sound-icon">ðŸ”Š</span>
      </button>
    </div>
  </header>

  <section class="hud">
    <div class="hud-block">
      <div>
        <div class="hud-label">Balance</div>
        <div class="hud-value accent" id="balance-value">1,000.00</div>
      </div>
      <div class="chip">Mode: <span>Demo</span></div>
    </div>

    <div class="hud-block">
      <div>
        <div class="hud-label">Total Bet</div>
        <div class="bet-control">
          <div class="bet-number" id="bet-value">1.00</div>
        </div>
      </div>
      <div class="bet-buttons">
        <button class="bet-btn" id="bet-dec">â€“</button>
        <button class="bet-btn" id="bet-inc">+</button>
      </div>
    </div>

    <div class="hud-block">
      <div>
        <div class="hud-label">Last Win</div>
        <div class="hud-value" id="last-win-value">0.00</div>
      </div>
      <div class="chip">Lines: <span>10 fixed</span></div>
    </div>
  </section>

  <section class="reel-wrapper">
    <div class="reel-overlay-top"></div>
    <div id="reels" class="reels"></div>
    <div class="reel-overlay-bottom"></div>
  </section>

  <section class="controls">
    <button id="auto-btn" class="btn btn-secondary">
      AUTO
      <span class="btn-label-sub">Select spins</span>
    </button>
    <button id="spin-btn" class="btn btn-primary">
      SPIN
    </button>
    <button id="turbo-btn" class="btn btn-secondary">
      TURBO
      <span class="btn-label-sub">Fast mode</span>
    </button>
  </section>

  <div class="status-bar">
    <div class="status-left">
      <div class="tag">3+ Bonus Holes: Free Spins</div>
      <div class="tag">Hammer collects moles in bonus</div>
      <div class="tag" id="fs-state-tag">Mode: Base Game</div>
    </div>
    <div>
      <span class="dot" id="auto-dot"></span>
      <span class="status-message" id="status-message"></span>
    </div>
  </div>

  <div class="help-text">
    Whack the moles to win. Payouts follow the original math profile. Free Spins: bonus moles pay with increasing multipliers.
  </div>

  <!-- AUTO PLAY MODAL -->
  <div id="auto-modal" class="auto-modal">
    <div class="auto-modal-backdrop"></div>
    <div class="auto-modal-panel">
      <div class="auto-modal-header">
        <div class="auto-modal-title">Auto Play</div>
        <button id="auto-close" class="auto-close">&times;</button>
      </div>
      <div class="auto-modal-subtitle">Select number of automatic spins</div>
      <div class="auto-option-grid">
        <button class="auto-option" data-spins="10">10</button>
        <button class="auto-option" data-spins="25">25</button>
        <button class="auto-option" data-spins="50">50</button>
        <button class="auto-option" data-spins="100">100</button>
        <button class="auto-option" data-spins="250">250</button>
        <button class="auto-option" data-spins="500">500</button>
        <button class="auto-option" data-spins="750">750</button>
        <button class="auto-option" data-spins="1000">1000</button>
      </div>
      <div class="auto-modal-actions">
        <button id="auto-start" class="btn btn-primary">Start Auto</button>
      </div>
    </div>
  </div>

  <!-- INFO MODAL -->
  <div id="info-modal" class="info-modal">
    <div class="info-modal-backdrop"></div>
    <div class="info-modal-panel">
      <div class="info-header">
        <div>
          <div class="info-title">How to Play</div>
          <div class="info-badge" style="margin-top:2px;">
            <span class="info-badge-dot"></span>
            <span>Target RTP ~97.99% â€¢ 10 Fixed Lines</span>
          </div>
        </div>
        <button id="info-close" class="info-close">&times;</button>
      </div>
      <div class="info-body">
        <div style="margin-bottom:8px;">
          <div class="info-section-title">Base Game</div>
          <p>BISH BASH BOSH is a 5Ã—3 whack-a-mole style slot with 10 fixed win lines, paying left to right.</p>
          <ul>
            <li>Select your <span class="info-highlight">Total Bet</span> using the â€“ / + buttons.</li>
            <li>Press <span class="info-highlight">SPIN</span> to play one paid game.</li>
            <li>All wins are paid as <span class="info-highlight">multiples of your total bet</span>.</li>
            <li>Only the highest win is paid per line.</li>
          </ul>
        </div>

        <div style="margin-bottom:8px;">
          <div class="info-section-title">Free Spins</div>
          <p><span class="info-highlight">Bonus Hole</span> symbols (SCATTER) trigger Free Spins:</p>
          <ul>
            <li>3 Bonus Holes = 10 Free Spins</li>
            <li>4 Bonus Holes = 15 Free Spins</li>
            <li>5 Bonus Holes = 20 Free Spins</li>
          </ul>
          <p>During Free Spins, hammer hits collect mole cash values with an increasing multiplier. Collect 4 hammers to level up and add extra Free Spins.</p>
        </div>

        <div style="margin-bottom:8px;">
          <div class="info-section-title">Paytable (Line Wins)</div>
          <p>Pays shown as <span class="info-highlight">x Total Bet</span> for 10-line play:</p>
          <table class="paytable-table">
            <thead>
              <tr>
                <th>Symbol</th>
                <th>2</th>
                <th>3</th>
                <th>4</th>
                <th>5</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>King Mole</td>
                <td>0.5</td>
                <td>20</td>
                <td>50</td>
                <td>250</td>
              </tr>
              <tr>
                <td>Grumpy Mole</td>
                <td>â€“</td>
                <td>5</td>
                <td>15</td>
                <td>150</td>
              </tr>
              <tr>
                <td>Helmet Mole</td>
                <td>â€“</td>
                <td>2</td>
                <td>10</td>
                <td>75</td>
              </tr>
              <tr>
                <td>Goggles Mole</td>
                <td>â€“</td>
                <td>3</td>
                <td>10</td>
                <td>75</td>
              </tr>
              <tr>
                <td>Cheeky Mole</td>
                <td>â€“</td>
                <td>1</td>
                <td>5</td>
                <td>25</td>
              </tr>
              <tr>
                <td>Scoreboard (A)</td>
                <td>â€“</td>
                <td>0.5</td>
                <td>2.5</td>
                <td>10</td>
              </tr>
              <tr>
                <td>Work Glove (K)</td>
                <td>â€“</td>
                <td>0.5</td>
                <td>2.5</td>
                <td>10</td>
              </tr>
              <tr>
                <td>Wooden Board (Q)</td>
                <td>â€“</td>
                <td>0.5</td>
                <td>2.5</td>
                <td>10</td>
              </tr>
              <tr>
                <td>Shallow Tunnel (J)</td>
                <td>â€“</td>
                <td>0.5</td>
                <td>2.5</td>
                <td>10</td>
              </tr>
              <tr>
                <td>Small Dirt Hole (10)</td>
                <td>â€“</td>
                <td>0.5</td>
                <td>2.5</td>
                <td>10</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div>
          <div class="info-section-title">Scatter & Feature</div>
          <p>Bonus Hole (SCAT) symbols pay as scatters by triggering the Free Spins feature only. Line wins and feature wins are added together.</p>
        </div>
      </div>
    </div>
  </div>

<div id="bigwin-overlay" class="bigwin-overlay">
  <div id="bigwin-amount" class="bigwin-amount">0.00</div>
</div>

</div>

<script>
  const WIN_SCALE = 1.045;

  const REEL_1 = [
    'A', 'J', '10', 'CM', 'K', 'Q', 'SCAT', 'J', 'A', 'HM',
    '10', 'K', 'SCAT', 'Q', 'CM', 'A', '10', 'GG', 'K', 'Q',
    'SCAT', 'J', 'GM', 'A', '10', 'K', 'CM', 'Q', 'SCAT', 'A',
    'KM', '10', 'K', 'Q', 'J', 'SCAT', 'CM', 'A', 'SCAT', '10',
  ];

  const REEL_2 = [
    'K', 'A', 'SCAT', 'Q', '10', 'CM', 'J', 'K', 'HM', 'A',
    'Q', 'SCAT', '10', 'CM', 'K', 'A', 'GG', 'Q', 'SCAT', '10',
    'K', 'A', 'GM', 'Q', 'SCAT', 'CM', '10', 'K', 'A', 'Q',
    'SCAT', 'J', 'KM', '10', 'HM', 'K', 'A', 'SCAT', 'Q', 'CM',
    '10', 'SCAT', 'J', 'CM',
  ];

  const REEL_3 = [
    'J', '10', 'SCAT', 'A', 'K', 'Q', 'CM', 'J', 'HM', 'A',
    '10', 'K', 'SCAT', 'Q', 'CM', 'A', 'GG', '10', 'K', 'Q',
    'SCAT', 'J', 'A', 'GM', '10', 'K', 'Q', 'SCAT', 'CM', 'J',
    'A', '10', 'SCAT', 'Q', 'KM', 'J', 'A', 'CM', '10', 'SCAT',
    'K', 'Q', 'HM', 'A', 'SCAT', 'CM', '10', 'GG',
  ];

  const REEL_4 = [
    'Q', 'A', '10', 'SCAT', 'K', 'CM', 'J', 'Q', 'A', 'HM',
    '10', 'K', 'SCAT', 'CM', 'A', '10', 'GG', 'K', 'SCAT', 'J',
    'Q', 'GM', 'A', '10', 'SCAT', 'CM', 'Q', 'J', 'A', 'KM',
    '10', 'K', 'SCAT', 'Q', 'CM', 'A', 'HM', '10', 'K', 'Q',
    'SCAT', 'CM', 'J', 'SCAT',
  ];

  const REEL_5 = [
    'A', 'K', 'Q', 'SCAT', '10', 'CM', 'J', 'A', 'K', 'HM',
    'Q', '10', 'SCAT', 'CM', 'A', 'K', 'GG', 'Q', 'SCAT', '10',
    'J', 'GM', 'A', 'K', 'Q', 'SCAT', 'CM', '10', 'A', 'KM',
    'K', 'Q', 'SCAT', '10', 'J', 'A', 'CM', 'K', 'SCAT', 'CM',
  ];

  const REELS = [REEL_1, REEL_2, REEL_3, REEL_4, REEL_5];

  const PAYTABLE = {
    '10':  { 3: 0.5, 4: 2.5, 5: 10 },
    'J':   { 3: 0.5, 4: 2.5, 5: 10 },
    'Q':   { 3: 0.5, 4: 2.5, 5: 10 },
    'K':   { 3: 0.5, 4: 2.5, 5: 10 },
    'A':   { 3: 0.5, 4: 2.5, 5: 10 },
    'CM': { 3: 1, 4: 5, 5: 25 },
    'HM': { 3: 2, 4: 10, 5: 75 },
    'GG': { 3: 3, 4: 10, 5: 75 },
    'GM': { 3: 5, 4: 15, 5: 150 },
    'KM': { 2: 0.5, 3: 20, 4: 50, 5: 250 },
  };

  const SYMBOL_INFO = {
    '10':   { name: 'Small Dirt Hole',    group: 'low'     },
    'J':    { name: 'Shallow Tunnel',     group: 'low'     },
    'Q':    { name: 'Wooden Board',       group: 'low'     },
    'K':    { name: 'Work Glove',         group: 'low'     },
    'A':    { name: 'Scoreboard',         group: 'low'     },
    'CM': { name: 'Cheeky Mole',        group: 'high'    },
    'HM': { name: 'Helmet Mole',        group: 'high'    },
    'GG': { name: 'Goggles Mole',       group: 'high'    },
    'GM': { name: 'Grumpy Mole',        group: 'high'    },
    'KM': { name: 'King Mole',          group: 'high'    },
    'SCAT': { name: 'Bonus Hole',         group: 'scatter' },
  };

  const LINES = [
    [1, 1, 1, 1, 1],
    [0, 0, 0, 0, 0],
    [2, 2, 2, 2, 2],
    [0, 1, 2, 1, 0],
    [2, 1, 0, 1, 2],
    [0, 0, 1, 2, 2],
    [2, 2, 1, 0, 0],
    [1, 0, 0, 0, 1],
    [1, 2, 2, 2, 1],
    [0, 1, 1, 1, 0],
  ];

  const ROWS = 3;
  const COLS = 5;

  const MODE_BASE = 'BASE';
  const MODE_FS = 'FS';

  const LEVEL_MULTIPLIERS = [1, 2, 3, 10];
  const FISH_VALUES = [0.1, 0.2, 0.3, 0.5, 1.0];

  let freeSpinsLeft = 0;
  let freeSpinsTotal = 0;
  let freeSpinsPlayed = 0;
  let totalFreeSpinsWin = 0;
  let freeSpinLevel = 1;
  let freeSpinMultiplier = LEVEL_MULTIPLIERS[0];
  let fishermenInLevel = 0;

  let mode = MODE_BASE;

  let balance = 1000.00;
  let bet = 1.00;
  let lastWin = 0.00;
  let turbo = false;
  let spinning = false;

  let autoMode = false;
  let autoSpinsRemaining = 0;
  let autoSpinsTotal = 0;
  let spinRequestedByAuto = false;

  let soundEnabled = true;
  let audioCtx = null;

  const cellGrid = [];
  const reelElems = [];

  const balanceEl = document.getElementById('balance-value');
  const betEl = document.getElementById('bet-value');
  const lastWinEl = document.getElementById('last-win-value');
  const statusMessageEl = document.getElementById('status-message');
  const autoDotEl = document.getElementById('auto-dot');
  const fsStateTagEl = document.getElementById('fs-state-tag');
  const fsBannerEl = document.getElementById('fs-banner');
  const fsBannerTextEl = document.getElementById('fs-banner-text');

  const spinBtn = document.getElementById('spin-btn');
  const autoBtn = document.getElementById('auto-btn');
  const turboBtn = document.getElementById('turbo-btn');
  const betDecBtn = document.getElementById('bet-dec');
  const betIncBtn = document.getElementById('bet-inc');

  const autoModal = document.getElementById('auto-modal');
  const autoCloseBtn = document.getElementById('auto-close');
  const autoStartBtn = document.getElementById('auto-start');
  const autoOptionButtons = Array.from(document.querySelectorAll('.auto-option'));
  const autoBackdrop = document.querySelector('.auto-modal-backdrop');

  const soundBtn = document.getElementById('sound-btn');
  const soundIcon = document.getElementById('sound-icon');
  const infoBtn = document.getElementById('info-btn');
  const infoModal = document.getElementById('info-modal');
  const infoCloseBtn = document.getElementById('info-close');
  const infoBackdrop = document.querySelector('.info-modal-backdrop');

  let autoSelectedSpins = 0;

  function getAudioCtx() {
    if (!audioCtx) {
      const Ctor = window.AudioContext || window.webkitAudioContext;
      if (Ctor) {
        audioCtx = new Ctor();
      }
    }
    return audioCtx;
  }

  function playTone(freq, duration, type = 'square', gain = 0.15) {
    if (!soundEnabled) return;
    const ctx = getAudioCtx();
    if (!ctx) return;
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    osc.connect(g);
    g.connect(ctx.destination);
    const now = ctx.currentTime;
    g.gain.setValueAtTime(gain, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + duration);
    osc.start(now);
    osc.stop(now + duration);
  }

  function sSpin()    { playTone(260, 0.10, 'square', 0.14); }
  function sStop()    { playTone(180, 0.08, 'square', 0.10); }
  function sWin()     { playTone(880, 0.18, 'triangle', 0.18); }
  function sFsTrigger(){ playTone(520, 0.20, 'sawtooth', 0.18); }
function sAnticipation() { playTone(420, 0.35, 'triangle', 0.12); }

  function sFsLevelUp(){ playTone(700, 0.22, 'square', 0.20); }
  function sClick()   { playTone(540, 0.05, 'square', 0.10); }

  (function initSoundState() {
    try {
      const stored = window.localStorage.getItem('bishBashSound');
      if (stored === 'off') soundEnabled = false;
    } catch (e) {}
    updateSoundIcon();
  })();

  function updateSoundIcon() {
    soundIcon.textContent = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
    soundBtn.classList.toggle('on', soundEnabled);
  }

  soundBtn.addEventListener('click', () => {
    sClick();
    soundEnabled = !soundEnabled;
    try {
      window.localStorage.setItem('bishBashSound', soundEnabled ? 'on' : 'off');
    } catch (e) {}
    updateSoundIcon();
    const ctx = getAudioCtx();
    if (soundEnabled && ctx && ctx.state === 'suspended') {
      ctx.resume();
    }
  });

  function formatMoney(value) {
    return value.toFixed(2);
  }

  function randomInt(max) {
    return Math.floor(Math.random() * max);
  }

  function setStatus(msg, type) {
    statusMessageEl.textContent = msg || '';
    statusMessageEl.className = 'status-message' + (type ? ' ' + type : '');
  }

  function updateFsBanner() {
    if (!fsBannerEl || !fsBannerTextEl) return;

    if (mode === MODE_FS) {
      const label = `FREE SPINS LEFT: ${freeSpinsLeft}`;
      fsBannerTextEl.textContent = label;
      fsBannerEl.classList.add('visible', 'active');
    } else {
      fsBannerTextEl.textContent = 'FREE SPINS LEFT';
      fsBannerEl.classList.remove('visible', 'active');
    }
  }

  function updateHUD() {
    balanceEl.textContent = formatMoney(balance);
    betEl.textContent = formatMoney(bet);
    lastWinEl.textContent = formatMoney(lastWin);

    spinBtn.disabled = spinning || (mode === MODE_BASE && balance < bet);
    betDecBtn.disabled = spinning || mode === MODE_FS;
    betIncBtn.disabled = spinning || mode === MODE_FS;
    autoDotEl.classList.toggle('on', autoMode && mode === MODE_BASE);

    if (fsStateTagEl) {
      if (mode === MODE_FS) {
        const nextSpinNumber = Math.min(freeSpinsPlayed + 1, freeSpinsTotal);
        const label = `Free Spins Â· Spin ${nextSpinNumber}/${freeSpinsTotal} Â· Left ${freeSpinsLeft} Â· Mult x${freeSpinMultiplier} Â· Moles ${fishermenInLevel}/4`;
        fsStateTagEl.textContent = label;
      } else {
        fsStateTagEl.textContent = 'Mode: Base Game';
      }
    }

    updateFsBanner();
  }

  function clearHighlights() {
    for (let c = 0; c < COLS; c++) {
      for (let r = 0; r < ROWS; r++) {
        const cell = cellGrid[c][r];
        cell.classList.remove('symbol-win');
      }
    }
  }

  function createReels() {
    const reelsContainer = document.getElementById('reels');

    for (let col = 0; col < COLS; col++) {
      const reel = document.createElement('div');
      reel.className = 'reel';
      reelElems[col] = reel;

      const colCells = [];
      for (let row = 0; row < ROWS; row++) {
        const cell = document.createElement('div');
     cell.className = 'symbol symbol-low';
        cell.dataset.col = String(col);
        cell.dataset.row = String(row);

        const art = document.createElement('div');
        art.className = 'symbol-art';
        art.innerHTML = `
          <div class="mole-hole"></div>
          <div class="mole-body"></div>
          <div class="mole-eye left"></div>
          <div class="mole-eye right"></div>
          <div class="mole-nose"></div>
          <div class="mole-teeth"></div>
          <div class="hammer-head"></div>
          <div class="hammer-handle"></div>
        `;

        

    // --- SYMBOL FRAME (WIN GLOW LIVES HERE) ---
const frame = document.createElement('div');
frame.className = 'symbol-frame';

// --- SYMBOL IMAGE ---
const img = document.createElement('img');
img.className = 'symbol-img';
img.src = '';
img.alt = '';

// IMPORTANT: frame FIRST, image SECOND
cell.appendChild(frame);
cell.appendChild(img);

// Add the cell to the reel
reel.appendChild(cell);

        colCells[row] = cell;
      }

      cellGrid[col] = colCells;
      reelsContainer.appendChild(reel);
    }
  }

  function renderGrid(grid) {
  for (let col = 0; col < COLS; col++) {
    for (let row = 0; row < ROWS; row++) {

      const symCode = grid[col][row];
      const cell = cellGrid[col][row];

      // safety check
      if (!cell) continue;

      // set symbol code on cell
      cell.setAttribute('data-symbol', symCode);

      // clear old symbol classes
      cell.classList.remove(
        'symbol-low',
        'symbol-high',
        'symbol-scatter',
        'symbol-win'
      );

      // PNG IMAGE ONLY
      const img = cell.querySelector('.symbol-img');
      if (img) {
        img.src = `assets/symbols/${symCode}.png`;
        img.alt = symCode;
      }
    }
  }
}

  function evaluateGridLines(grid) {
    let totalWin = 0;

    for (let lineIndex = 0; lineIndex < LINES.length; lineIndex++) {
      const pattern = LINES[lineIndex];
      const firstRow = pattern[0];
      const firstSymbol = grid[0][firstRow];

      if (!firstSymbol) continue;
      if (firstSymbol === 'SCAT') continue;

      const pay = PAYTABLE[firstSymbol];
      if (!pay) continue;

      let length = 1;
      for (let col = 1; col < COLS; col++) {
        const row = pattern[col];
        const symbol = grid[col][row];
        if (symbol !== firstSymbol || symbol === 'SCAT') break;
        length++;
      }

      const payoff = pay[length];
      if (payoff) {
        const lineWin = payoff * bet;
        totalWin += lineWin;
      }
    }

    return totalWin;
  }

  function highlightWinPositions(positions) {
    const seen = new Set();
    positions.forEach(pos => {
      const key = pos.col + ':' + pos.row;
      if (seen.has(key)) return;
      seen.add(key);
      const cell = cellGrid[pos.col][pos.row];
      cell.classList.add('symbol-win');
    });
  }

  function countScatters(grid) {
    let scatters = 0;
    for (let c = 0; c < COLS; c++) {
      for (let r = 0; r < ROWS; r++) {
        if (grid[c][r] === 'SCAT') scatters++;
      }
    }
    return scatters;
  }

  function sampleFishermenCount() {
    const r = Math.random();
    if (r < 0.95) return 0;
    if (r < 0.999) return 1;
    if (r < 0.9995) return 2;
    return 3;
  }

  function evaluateFreeSpinExtras(grid) {
    const fishPositions = [];
    for (let c = 0; c < COLS; c++) {
      for (let r = 0; r < ROWS; r++) {
        if (grid[c][r] === 'CM') {
          fishPositions.push({ col: c, row: r });
        }
      }
    }

    let totalFishBase = 0;
    if (fishPositions.length > 0) {
      for (let i = 0; i < fishPositions.length; i++) {
        const step = FISH_VALUES[randomInt(FISH_VALUES.length)];
        totalFishBase += step * bet;
      }
    }

    const fishermen = sampleFishermenCount();
    const collectBase = totalFishBase * fishermen;
    const collectWin = collectBase * freeSpinMultiplier;

    return {
      collectWin,
      fishermen,
      fishPositions
    };
  }

  function applyFishermenProgress(count) {
    if (count <= 0) return 0;
    let levelUps = 0;
    fishermenInLevel += count;

    while (fishermenInLevel >= 4 && freeSpinLevel < LEVEL_MULTIPLIERS.length) {
      fishermenInLevel -= 4;
      freeSpinLevel++;
      freeSpinMultiplier = LEVEL_MULTIPLIERS[freeSpinLevel - 1];
      freeSpinsLeft += 5;
      freeSpinsTotal += 5;
      levelUps++;
    }

    return levelUps;
  }

  function performSpin() {
    const grid = [];
    for (let col = 0; col < COLS; col++) {
      const reelStrip = REELS[col];
      const len = reelStrip.length;
      const start = randomInt(len);

      const colSymbols = [];
      for (let row = 0; row < ROWS; row++) {
        const idx = (start + row) % len;
        colSymbols[row] = reelStrip[idx];
      }
      grid[col] = colSymbols;
    }

    renderGrid(grid);

    const lineWin = evaluateGridLines(grid);
    
    const scatterCount = countScatters(grid);

    // Scatter anticipation: if 2 scatters already, slow last reels
    if (scatterCount >= 2 && mode === MODE_BASE) {
      reelElems.forEach((reel, i) => {
        if (i >= COLS - 2) {
          reel.classList.add('anticipation'); sAnticipation();
        }
      });
    }


    let fsExtras = { collectWin: 0, fishermen: 0, fishPositions: [] };
    if (mode === MODE_FS) {
      fsExtras = evaluateFreeSpinExtras(grid);
    }

    const rawTotalWin = lineWin + fsExtras.collectWin;
    const scaledTotalWin = rawTotalWin * WIN_SCALE;

    const winningPositions = [];

    for (let lineIndex = 0; lineIndex < LINES.length; lineIndex++) {
      const pattern = LINES[lineIndex];
      const firstRow = pattern[0];
      const firstSymbol = grid[0][firstRow];

      if (!firstSymbol || firstSymbol === 'SCAT') continue;
      const pay = PAYTABLE[firstSymbol];
      if (!pay) continue;

      let length = 1;
      for (let col = 1; col < COLS; col++) {
        const row = pattern[col];
        const symbol = grid[col][row];
        if (symbol !== firstSymbol || symbol === 'SCAT') break;
        length++;
      }

      if (pay[length]) {
        for (let col = 0; col < length; col++) {
          const row = pattern[col];
          winningPositions.push({ col, row });
        }
      }
    }

    if (winningPositions.length > 0) {
      highlightWinPositions(winningPositions);
      const reelWrap = document.querySelector('.reel-wrapper');
      const sweep = document.createElement('div');
      sweep.className = 'line-sweep';
      reelWrap.appendChild(sweep);
      setTimeout(() => sweep.remove(), 400);

    }
    if (mode === MODE_FS && fsExtras.collectWin > 0 && fsExtras.fishPositions.length > 0) {
      highlightWinPositions(fsExtras.fishPositions);
    }

    if (scaledTotalWin > 0) {
      balance += scaledTotalWin;
    }

    return {
      grid,
      lineWin,
      rawTotalWin,
      totalWin: scaledTotalWin,
      scatterCount,
      fsCollectWin: fsExtras.collectWin * WIN_SCALE,
      fishermen: fsExtras.fishermen,
      winningPositions
    };
  }

  function triggerFreeSpins(scatterCount) {
    const awarded = scatterCount === 3 ? 10 : (scatterCount === 4 ? 15 : 20);

    mode = MODE_FS;
    freeSpinsLeft = awarded;
    freeSpinsTotal = awarded;
    freeSpinsPlayed = 0;
    totalFreeSpinsWin = 0;
    freeSpinLevel = 1;
    freeSpinMultiplier = LEVEL_MULTIPLIERS[0];
    fishermenInLevel = 0;

    sFsTrigger();
    setStatus(`Free Spins triggered: ${awarded} spins awarded`, 'win');
    updateHUD();
  }

  function stopAuto(message, type) {
    autoMode = false;
    autoSpinsRemaining = 0;
    autoSpinsTotal = 0;
    spinRequestedByAuto = false;
    autoBtn.classList.remove('toggled');
    autoDotEl.classList.remove('on');
    if (message) {
      setStatus(message, type || '');
    }
    updateHUD();
  }

  function spinOnce() {
    if (spinning) return;

    const wasAutoSpin = spinRequestedByAuto;
    spinRequestedByAuto = false;

    if (mode === MODE_BASE && balance < bet) {
      if (wasAutoSpin && autoMode) {
        stopAuto('Auto stopped (balance too low)', 'error');
      } else {
        setStatus('Insufficient balance', 'error');
        updateHUD();
      }
      return;
    }

    spinning = true;
    clearHighlights();
    setStatus('Spinningâ€¦', '');
    if (mode === MODE_BASE) {
      balance -= bet;
    }
    updateHUD();

    sSpin();

    const delay = turbo ? 90 : 420;

    reelElems.forEach(r => r.classList.add('spinning'));

    setTimeout(() => {
      const result = performSpin();
      spinning = false;
      
      // Staggered reel stop (left â†’ right)
      reelElems.forEach((reel, i) => {
        setTimeout(() => {
          reel.classList.remove('spinning'); reel.classList.remove('anticipation');
          reel.classList.add('stopping');
          setTimeout(() => {
            reel.classList.remove('stopping');
            reel.classList.add('stopped');
          }, 80);
        }, i * (turbo ? 40 : 120));
      });


      sStop();

      lastWin = result.totalWin;
      if (result.totalWin >= bet * 20) {
        const overlay = document.getElementById('bigwin-overlay');
        const amountEl = document.getElementById('bigwin-amount');
        overlay.classList.add('show');
        let current = 0;
        const target = result.totalWin;
        const step = target / 30;
        const interval = setInterval(() => {
          current += step;
          if (current >= target) {
            current = target;
            clearInterval(interval);
            setTimeout(() => overlay.classList.remove('show'), 600);
          }
          amountEl.textContent = current.toFixed(2);
        }, 30);
      }

      // Big win reel effects
      if (result.totalWin >= bet * 10) {
        const finalReel = reelElems[COLS - 1];
        finalReel.classList.add('final-bounce');
        setTimeout(() => finalReel.classList.remove('final-bounce'), 320);
      }

      if (result.winningPositions && result.winningPositions.length > 0) {
        const winningReels = new Set(result.winningPositions.map(p => p.col));
        winningReels.forEach(col => {
          const r = reelElems[col];
          r.classList.add('win-rail');
          setTimeout(() => r.classList.remove('win-rail'), 900);
        });
      }

      updateHUD();

      if (mode === MODE_BASE) {
        if (wasAutoSpin && autoMode && autoSpinsRemaining > 0) {
          autoSpinsRemaining--;
          if (autoSpinsRemaining <= 0) {
            stopAuto('Auto complete', '');
          }
        }

        if (result.totalWin > 0) {
          sWin();
          setStatus('Win ' + formatMoney(result.totalWin) + ' credits', 'win');
        } else {
          setStatus('No win', '');
        }

        if (result.scatterCount >= 3) {
          triggerFreeSpins(result.scatterCount);
          const gapFS = turbo ? 120 : 500;
          setTimeout(spinOnce, gapFS);
        } else if (autoMode && autoSpinsRemaining > 0 && balance >= bet) {
          const gap = turbo ? 80 : 350;
          spinRequestedByAuto = true;
          setTimeout(spinOnce, gap);
        } else if (autoMode && autoSpinsRemaining > 0 && balance < bet) {
          stopAuto('Auto stopped (balance too low)', 'error');
        }
      } else if (mode === MODE_FS) {
        freeSpinsLeft--;
        freeSpinsPlayed++;
        totalFreeSpinsWin += result.totalWin;

        const levelUps = applyFishermenProgress(result.fishermen);

        let msgParts = [`Free Spin ${freeSpinsPlayed}/${freeSpinsTotal}`];
        if (result.totalWin > 0) {
          sWin();
          msgParts.push('win ' + formatMoney(result.totalWin));
        } else {
          msgParts.push('no win');
        }
        if (result.fsCollectWin > 0) {
          msgParts.push('mole bonus ' + formatMoney(result.fsCollectWin));
        }
        if (result.fishermen > 0) {
          msgParts.push('hammer hits ' + result.fishermen);
        }
        if (levelUps > 0) {
          sFsLevelUp();
          msgParts.push('LEVEL UP x' + freeSpinMultiplier);
        }

        setStatus(msgParts.join(' Â· '), result.totalWin > 0 ? 'win' : '');
        updateHUD();

        if (freeSpinsLeft > 0) {
          const gap = turbo ? 120 : 500;
          setTimeout(spinOnce, gap);
        } else {
          mode = MODE_BASE;
          setStatus(
            'Free Spins complete Â· total feature win ' + formatMoney(totalFreeSpinsWin),
            totalFreeSpinsWin > 0 ? 'win' : ''
          );
          updateHUD();
          if (autoMode && autoSpinsRemaining > 0 && balance >= bet) {
            const gap = turbo ? 80 : 350;
            spinRequestedByAuto = true;
            setTimeout(spinOnce, gap);
          }
        }
      }
    }, delay);
  }

  function openAutoModal() {
    if (spinning || mode === MODE_FS) return;
    autoSelectedSpins = 0;
    autoOptionButtons.forEach(btn => btn.classList.remove('selected'));
    autoModal.classList.add('open');
  }

  function closeAutoModal() {
    autoModal.classList.remove('open');
  }

  function openInfoModal() {
    if (spinning) return;
    infoModal.classList.add('open');
  }

  function closeInfoModal() {
    infoModal.classList.remove('open');
  }

  autoOptionButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      sClick();
      autoOptionButtons.forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      autoSelectedSpins = parseInt(btn.dataset.spins, 10) || 0;
    });
  });

  autoCloseBtn.addEventListener('click', () => {
    sClick();
    closeAutoModal();
  });
  if (autoBackdrop) {
    autoBackdrop.addEventListener('click', closeAutoModal);
  }

  if (infoBtn) {
    infoBtn.addEventListener('click', () => {
      sClick();
      openInfoModal();
    });
  }
  if (infoCloseBtn) {
    infoCloseBtn.addEventListener('click', () => {
      sClick();
      closeInfoModal();
    });
  }
  if (infoBackdrop) {
    infoBackdrop.addEventListener('click', closeInfoModal);
  }

  autoStartBtn.addEventListener('click', () => {
    sClick();
    if (!autoSelectedSpins) {
      setStatus('Select number of auto spins', 'error');
      return;
    }
    if (balance < bet) {
      setStatus('Cannot start auto â€“ balance too low', 'error');
      closeAutoModal();
      return;
    }
    autoMode = true;
    autoSpinsRemaining = autoSelectedSpins;
    autoSpinsTotal = autoSelectedSpins;
    autoBtn.classList.add('toggled');
    autoDotEl.classList.add('on');
    setStatus(`Auto play started: ${autoSpinsTotal} spins`, '');
    closeAutoModal();
    updateHUD();
    if (!spinning && mode === MODE_BASE) {
      spinRequestedByAuto = true;
      spinOnce();
    }
  });

  spinBtn.addEventListener('click', () => {
    if (mode === MODE_FS) return;
    const ctx = getAudioCtx();
    if (ctx && ctx.state === 'suspended' && soundEnabled) {
      ctx.resume();
    }
    if (autoMode) {
      stopAuto('Auto play stopped', '');
    }
    spinRequestedByAuto = false;
    spinOnce();
  });

  autoBtn.addEventListener('click', () => {
    if (mode === MODE_FS) return;
    if (autoMode) {
      stopAuto('Auto play stopped', '');
    } else {
      openAutoModal();
    }
  });

  turboBtn.addEventListener('click', () => {
    turbo = !turbo;
    turboBtn.classList.toggle('toggled', turbo);
    setStatus(turbo ? 'Turbo mode ON' : 'Turbo mode OFF', '');
  });

  const MIN_BET = 0.20;
  const MAX_BET = 20.00;
  const BET_STEP = 0.20;

  betDecBtn.addEventListener('click', () => {
    if (spinning || mode === MODE_FS) return;
    bet = Math.max(MIN_BET, bet - BET_STEP);
    bet = Math.round(bet * 100) / 100;
    updateHUD();
  });

  betIncBtn.addEventListener('click', () => {
    if (spinning || mode === MODE_FS) return;
    bet = Math.min(MAX_BET, bet + BET_STEP);
    bet = Math.round(bet * 100) / 100;
    updateHUD();
  });

  createReels();

  (function initialPopulate() {
    const grid = [];
    for (let col = 0; col < COLS; col++) {
      const reelStrip = REELS[col];
      const len = reelStrip.length;
      const start = randomInt(len);
      const colSymbols = [];
      for (let row = 0; row < ROWS; row++) {
        const idx = (start + row) % len;
        colSymbols[row] = reelStrip[idx];
      }
      grid[col] = colSymbols;
    }
    renderGrid(grid);
  })();

  updateHUD();
  setStatus('Ready. Set your bet and whack the moles. 3+ Bonus Holes start Free Spins.', '');
</script>
</body>
</html>
